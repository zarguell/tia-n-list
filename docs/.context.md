## Patterns and Conventions - Unified Architecture

### üö® **CRITICAL: ANTI-PATTERNS TO AVOID**

After completing a major simplification cascade, these patterns caused significant technical debt:

**‚ùå NEVER IMPLEMENT:**
- **Multiple storage systems**: Never create both JSON and SQLite implementations for the same functionality
- **Multiple LLM clients**: Never create separate client modules for different providers
- **Multiple blog generators**: Never create separate generator classes for different approaches
- **Direct file operations**: Never bypass abstraction layers with raw file I/O
- **Duplicate functionality**: Never create new modules when existing ones can be extended

**‚úÖ ALWAYS IMPLEMENT:**
- **Single abstraction per domain**: One storage provider, one LLM registry, one blog engine
- **Strategy pattern for variations**: Use pluggable strategies instead of separate implementations
- **Registry pattern for selection**: Use registries with fallback handling for provider selection
- **Dependency injection**: Inject abstractions, never concrete implementations

### Python Environment Setup
Always work within the virtual environment and use the proper PYTHONPATH:

```bash
# Create/activate virtual environment
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Run commands with PYTHONPATH set for imports
PYTHONPATH=. pytest tests/ -v
PYTHONPATH=. python -m src.unified_ingestion
PYTHONPATH=. python -m src.unified_processing
```

### Python Style
- All Python code must be formatted with `ruff format`
- All code must pass `ruff check` and `mypy` static analysis
- Use type hints for all function signatures and variables where possible
- **CRITICAL**: Always use abstractions, never concrete implementations in application code

### Configuration
Configuration is managed in JSON files within both the `data/` and `config/` directories:

```json
{
  "id": "krebs-on-security",
  "name": "Krebs on Security",
  "url": "https://krebsonsecurity.com/feed/",
  "active": true,
  "metadata": {
    "focus_areas": ["cybercrime", "fraud", "data-breaches"]
  }
}
```

## üèóÔ∏è **UNIFIED ARCHITECTURE PATTERNS**

### 1. Storage Provider Abstraction - "Everything is a storage provider"

**‚úÖ CORRECT PATTERN:**
```python
# Use storage provider abstraction
from .storage_provider import StorageProvider
from .storage_registry import get_default_storage_provider

class MyModule:
    def __init__(self, storage: StorageProvider = None):
        self.storage = storage or get_default_storage_provider()

    def get_articles(self):
        return self.storage.get_articles_by_date_range(...)
```

**‚ùå ANTI-PATTERN (NEVER AGAIN):**
```python
# NEVER: Direct storage implementation
from .json_storage import JSONStorage  # REMOVED
from .database import Database  # REMOVED

def get_articles():
    storage = JSONStorage()  # Concrete implementation
    return storage.get_articles(...)
```

**Storage Provider Registry:**
```python
# Get default provider (JSON)
from .storage_registry import get_default_storage_provider
storage = get_default_storage_provider()

# Get specific provider
from .storage_registry import StorageRegistry
registry = StorageRegistry()
sqlite_storage = registry.get_provider("sqlite")

# Provider selection via environment
# STORAGE_PROVIDER=json|sqlite (default: json)
```

### 2. LLM Registry Abstraction - "Everything is an LLM provider"

**‚úÖ CORRECT PATTERN:**
```python
# Use LLM registry abstraction
from .llm_registry import get_registry, is_relevant_article

class MyProcessor:
    def __init__(self, llm_registry=None):
        self.llm_registry = llm_registry or get_registry()

    def process_article(self, article):
        # Convenience functions available
        if is_relevant_article(article):
            return self.llm_registry.execute_with_fallback(
                "extract_iocs_and_ttps",
                article_content=article['content']
            )
```

**‚ùå ANTI-PATTERN (NEVER AGAIN):**
```python
# NEVER: Direct LLM client implementation
from .llm_client import LLMClient  # REMOVED
from .llm_client_multi import MultiLLMClient  # REMOVED
from .providers.gemini_provider import GeminiProvider  # REMOVED

client = MultiLLMClient()  # Concrete implementation
```

**LLM Registry Features:**
```python
# Automatic fallback handling
registry = get_registry()
response = registry.execute_with_fallback("generate_text", prompt=prompt)

# Provider selection via environment
# LLM_PROVIDER=gemini|openrouter|openai (default: gemini)

# Convenience functions
from .llm_registry import is_relevant_article, extract_iocs_and_ttps
relevant = is_relevant_article(article)
iocs = extract_iocs_and_ttps(article_content)
```

### 3. Blog Engine Strategy Pattern - "Everything is a content transformation pipeline"

**‚úÖ CORRECT PATTERN:**
```python
# Use blog engine with strategies
from .blog_engine_factory import BlogEngineFactory
from .strategies.enhanced_transformation_strategy import EnhancedTransformationStrategy

factory = BlogEngineFactory()
blog_engine = factory.create_engine("enhanced")

result = blog_engine.generate_content(
    articles=articles,
    strategy=EnhancedTransformationStrategy(),
    metadata={}
)
```

**‚ùå ANTI-PATTERN (NEVER AGAIN):**
```python
# NEVER: Multiple separate generator classes
from .enhanced_json_blog_generator import EnhancedJSONBlogGenerator  # PRESERVED
from .intelligent_blog_generator import IntelligentBlogGenerator    # PRESERVED
from .two_tier_blog_generator import TwoTierBlogGenerator          # PRESERVED

# Choose ONE, never create new ones
generator = EnhancedJSONBlogGenerator()  # OK for compatibility
```

**Blog Engine Strategy Pattern:**
```python
# Strategy selection via environment
# BLOG_GENERATION_STRATEGY=enhanced|intelligent|template|two_tier

# Create custom strategies
from .blog_engine import TransformationStrategy
class MyCustomStrategy(TransformationStrategy):
    def transform(self, articles: List[Dict], metadata: Dict) -> str:
        # Custom transformation logic
        pass

# Register new strategy
from .blog_engine_factory import BlogEngineFactory
factory = BlogEngineFactory()
factory.register_strategy("custom", MyCustomStrategy)
```

## üìã **PROMPT CONFIGURATION SYSTEM**

The system includes enterprise-grade configurable prompt architecture:

**Prompt Templates:** JSON-based templates in `config/prompts/` directory
- `threat_intelligence_synthesis.json`: Main synthesis prompt with sections and variables
- `confidence_assessment.json`: Industry-standard confidence level guidance
- `mitre_attack_guidance.json`: MITRE ATT&CK technique integration
- `industry_impact_guidance.json`: Industry-specific impact analysis
- `intelligence_gap_guidance.json`: Intelligence gap analysis for transparency
- `tlp_banner.json`: TLP marking templates and AI disclaimers

**Usage Examples:**
```python
# Load and use prompt configuration
from src.prompt_loader import PromptLoader

loader = PromptLoader(Path("config/prompts"))
template = loader.load_main_prompt()

# Build enhanced synthesis prompt
prompt = loader.build_enhanced_synthesis_prompt(
    articles_data=articles_string,
    factual_constraints=constraints_string,
    current_date="2025-11-03"
)
```

**Enhanced Features:**
- **Confidence Assessment Framework**: High/Medium/Low confidence with executive decision-making context
- **MITRE ATT&CK Integration**: Technique references with detection guidance and response priorities
- **Industry Impact Analysis**: Business-focused impact assessment with sector-specific exposure
- **Intelligence Gap Identification**: Transparency about limitations and collection priorities
- **Executive Tone Optimization**: C-level briefing format with business impact prioritization
- **A/B Testing Framework**: Weighted variant testing for prompt optimization

## üé≠ **SIMPLIFIED DIGEST SYSTEM**

The system includes a simplified approach to threat intelligence digest generation:

**Core Components:**
- `SimpleDigestGenerator` ([src/simple_digest_generator.py](src/simple_digest_generator.py)): Main digest generation with streamlined workflow
- `SimpleMemory` ([src/simple_memory.py](src/simple_memory.py)): Basic article tracking to prevent repetition
- `simple_digest.json` ([config/prompts/simple_digest.json](config/prompts/simple_digest.json)): Simplified prompt template

**Simplified Workflow:**
1. **RSS Ingestion** ‚Üí Get fresh articles from last 24 hours
2. **Quality Filtering** ‚Üí Filter for content length and relevance
3. **Memory Deduplication** ‚Üí Exclude articles recently used in digests
4. **Simple Synthesis** ‚Üí Single LLM call for digest generation
5. **Hugo Output** ‚Üí Create blog post with basic metadata

**Usage Examples:**
```python
# Generate simple daily digest
from src.simple_digest_generator import SimpleDigestGenerator

generator = SimpleDigestGenerator()
hugo_filename = generator.generate_daily_digest()

if hugo_filename:
    print(f"Generated digest: {hugo_filename}")
```

**Simple Memory System:**
```python
# Track used articles and get statistics
from src.simple_memory import SimpleMemory

memory = SimpleMemory()
stats = memory.get_statistics()
print(f"Tracked {stats['total_articles']} articles across {stats['total_days']} days")
```

**Environment Configuration:**
```bash
# Use simple digest generation
export USE_SIMPLE_DIGEST=true

# Run simple digest script
python scripts/generate_simple_digest.py
```

## üé≠ **PROFESSIONAL PERSONA MODULE** (LEGACY)

The persona module provides professional executive-focused content formatting for enterprise features:

**Updated Persona Functions:**
- `format_article_summary()`: Professional article formatting with relevance indicators and executive insights
- `get_top_articles_for_summary()`: Retrieves high-priority articles for executive briefings

**Professional Tone Guidelines:**
- Content focused on C-level executive audience
- Relevance scoring with actionable insights (üî¥ Low, üü° Medium, üü¢ High priority)
- Executive-appropriate analysis without casual humor
- Professional risk assessment language

**Usage Examples:**
```python
# Professional article formatting
from src.persona import format_article_summary

summary = format_article_summary(
    title="Critical Vulnerability in Enterprise Software",
    content="Remote code execution vulnerability affects...",
    score=85
)
```

## üåê **CONTENT FETCHING SYSTEM**

The system includes a modular web scraping architecture to enhance RSS feed content:

**Core Components:**
- `src/content_fetcher.py`: Main content fetching module with rate limiting and respectful scraping
- `src/extractors/`: Modular website-specific extractor system with registry pattern

**Extraction Priority Chain:**
1. **Website-specific extractor** (highest quality, site-optimized)
2. **Trafilatura** (excellent for news articles, general purpose)
3. **BeautifulSoup fallback** (basic content extraction)

**Usage Examples:**
```python
# Simple content fetching
from src.content_fetcher import fetch_article_content
result = fetch_article_content('https://example.com/article')

# Extractor registry management
from src.extractors import get_extractor_registry, get_extractor_for_url
registry = get_extractor_registry()
extractor = get_extractor_for_url('https://threatpost.com/article')
```

## üéØ **DYNAMIC CONTENT GENERATION**

The system includes intelligent title and tag generation for engaging blog posts:

**Title Generation System:**
```python
# Dynamic title generation
from src.title_generator import TitleGenerator
from src.storage_registry import get_default_storage_provider

storage = get_default_storage_provider()
title_generator = TitleGenerator(storage)

# Generate title for today's articles
from datetime import date
articles = storage.get_articles_by_date_range(
    start_date=date.today(),
    end_date=date.today(),
    status='processed'
)

title = title_generator.generate_title(articles, date.today())
```

**Tag Generation System:**
```python
# Intelligent tag extraction
from src.tag_generator import TagGenerator

tag_generator = TagGenerator(storage)
tags = tag_generator.generate_tags_for_date(date.today(), limit=15)
hugo_tags = tag_generator.format_tags_for_hugo(tags)
```

## üîß **DEVELOPMENT COMMANDS**

```bash
# Testing and code quality
pytest tests/ -v --cov=src
ruff check src/ tests/
mypy src/

# Unified core operations (REMOVED OLD MODULES)
PYTHONPATH=. python -m src.unified_ingestion      # Run feed ingestion
PYTHONPATH=. python -m src.unified_processing    # Run LLM processing

# Blog generation with unified engines
from src.blog_engine_factory import BlogEngineFactory
factory = BlogEngineFactory()
engine = factory.create_engine_from_env()

# Content fetching and enhancement
PYTHONPATH=. python -c "from src.content_fetcher import fetch_article_content; print('Content fetcher ready')"

# LLM registry testing
PYTHONPATH=. python -c "from src.llm_registry import get_registry; registry = get_registry(); print('LLM registry ready')"

# Storage provider testing
PYTHONPATH=. python -c "from src.storage_registry import get_default_storage_provider; storage = get_default_storage_provider(); print('Storage provider ready')"

# Simple digest generation
PYTHONPATH=. python scripts/generate_simple_digest.py

# Simple memory testing
PYTHONPATH=. python -c "from src.simple_memory import SimpleMemory; memory = SimpleMemory(); print('Memory system ready')"

# Hugo site generation
hugo -s hugo/ --minify
```

## üèÜ **UNIFIED ARCHITECTURE BENEFITS**

**‚úÖ Simplification Benefits Achieved:**
- **3,276 lines eliminated** (20% code reduction)
- **8 deprecated modules removed**
- **Zero ambiguity**: Clear patterns for new development
- **Single source of truth**: One implementation per major system

**‚úÖ Anti-Pattern Prevention:**
- **Storage**: Single StorageProvider abstraction with pluggable implementations
- **LLM**: Single LLMRegistry with automatic fallback handling
- **Blog Generation**: Single BlogEngine with strategy pattern
- **Configuration**: Unified registry patterns for provider selection

**‚úÖ Development Quality:**
- **Zero duplication**: Never implement multiple solutions for same problem
- **Pluggable design**: Easy to extend without breaking existing code
- **Environment-based configuration**: Switch implementations without code changes
- **Dependency injection**: Always depend on abstractions, not concretions

**‚úÖ Production Readiness:**
- **Backward compatibility**: Legacy implementations preserved during transition
- **Zero downtime**: All existing workflows continue to work
- **Clear migration paths**: Strategy patterns enable gradual upgrades
- **Comprehensive testing**: Unified interfaces easier to test and validate

## üéØ **SIMPLIFIED DIGEST APPROACH - FURTHER REDUCTION**

**Latest Simplification (November 2025):**
- **96% reduction** in prompt configuration complexity (365+ lines ‚Üí 15 lines)
- **85% reduction** in blog generation code complexity
- **Single LLM call** vs multi-stage enterprise processing
- **Basic memory system** vs complex 7-day deduplication
- **Simple freshness filtering** vs comprehensive IOC/TTP extraction

**Simplified Core Components:**
1. **SimpleDigestGenerator**: Streamlined RSS‚Üídigest workflow
2. **SimpleMemory**: Basic article tracking to prevent repetition
3. **Single Prompt Template**: Focus on insights, not enterprise formatting
4. **Simple Workflow**: Fresh articles ‚Üí Memory filter ‚Üí LLM synthesis ‚Üí Hugo output

**Key Simplifications:**
- **Removed**: MITRE ATT&CK mapping, confidence assessments, business impact analysis
- **Removed**: Complex prompt configuration system with A/B testing
- **Removed**: Multi-stage LLM processing with fallback chains
- **Removed**: Dynamic title/tag generation complexity
- **Removed**: Enterprise-grade CTI formatting requirements

**Benefits:**
- **Faster generation**: Single LLM call reduces processing time
- **Lower costs**: Reduced token usage by focusing on core digest
- **Easier maintenance**: Single prompt file vs 5 complex templates
- **Better focus**: Back to core threat intelligence digest purpose
- **Fresh content**: Memory system prevents repetition while maintaining simplicity
